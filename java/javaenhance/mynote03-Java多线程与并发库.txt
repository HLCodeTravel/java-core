课程目录：
01. 传统线程技术回顾
02. 传统定时器技术回顾
03. 传统线程互斥技术
04. 传统线程同步通信技术
05. 线程范围内共享变量的概念与作用
06. ThreadLocal类及应用技巧
07. 多个线程之间共享数据的方式探讨
08. java5原子性操作类的应用
09. java5线程并发库的应用
10. Callable与Future的应用
11. java5的线程锁技术
12. java5读写锁技术的妙用
13. java5条件阻塞Condition的应用
14. java5的Semaphere同步工具
15. java5的CyclicBarrier同步工具
16. java5的CountDownLatch同步工具
17. java5的Exchanger同步工具
18. java5阻塞队列的应用
19. java5同步集合类的应用
20. 空中网挑选实习生的面试题1
21. 空中网挑选实习生的面试题2
22. 空中网挑选实习生的面试题3
23. 源代码与资料

------------------------------------------------
01_传统线程技术回顾

-创建线程的两种传统方式
    -方式1：继承Thread类，覆写run方法（run并不是抽象方法，Thread也不是抽象类）
    -方式2：实现Runnable接口，覆写run方法，将实例传递给Thread的构造方法。
    -多线程机制会提高程序的运行效率吗？为什么会有多线程下载呢？

-Thread 和 Runnable的区别：
 Runnable更能体现面向接口编程。建议实现Runnable接口，而不是继承Thread覆写run方法


代码，TraditionalThread

------------------------------------------------
02_传统定时器技术回顾
-Timer  定时器
-TimerTask  定时任务

schedule 调度

举例
定时收邮件等。
quartz工具，可以解决定时操作的需求。
生病了，要知道需要吃什么药，之前没吃过这个药也没问题。不知道吃什么药是个大问题。

------------------------------------------------
03_传统线程互斥技术
-线程的同步互斥与通信
    -使用synchronized代码块及其原理
    -使用synchronized方法
    -分析静态方法所使用的同步监视器对象是什么？
    -wait和notify实现线程间的通信
        -经验：要用到共同数据（包括同步锁）的若干个方法应该归在同一个类身上，这种设计正好体现了高类聚和程序的健壮性。

任何对象都可以作为锁，但是一直使用同一把锁来锁同一个门（同一个门栓），才可以起到互斥的效果。
静态的synchronized方法，使用的锁是字节码。

synchronized代码块和一个锁对象
synchronized方法和默认的锁对象
静态方法使用的同步监视器对象是静态代码块。

用什么进行互斥分组，就是通过synchronized（obj）中的obj不同，而分为不同的互斥组。


------------------------------------------------
04_传统线程同步通信技术
练习：
    子线程循环2次，接着主线程循环3，接着又回到子线程2次，
    接着再回到主线程又循环3次，如此循环5次，请写出程序。


------------------------------------------------
05_线程范围内共享变量的概念与作用

关于线程范围内的变量共享的举例，
创建三个线程，它们都访问了三个对象，第一个对象设置值，第二三个对象取值，同一个线程设置的值，只能被相同的线程获取。

首先用如下代码来说明如何实现全局共享：
class GlobalData{
    public static ThreadLocal var = new ThreadLocal();
}

全局静态变量可以被多个模块类共享，并且不管是哪个线程来调用，数据都是同一份。


------------------------------------------------
06_ThreadLocal类及应用技巧

ThreadLocal的作用和目的：
    用于实现线程内的数据共享，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据。

每个线程调用全局ThreadLocal对象的set方法，就相当于往其内部的map中增加一条记录，key分别是各自的线程，value是各自的set方法传进去的值。
    在此案城结束时可以调用ThreadLocal.clear方法，这样会更快释放内存，不调用也可以，因为线程结束后也可以自动释放相关的ThreadLocal变量。

ThreadLocal的应用场景：
    银行转账包含一些列操作：把转出账户的余额减少，把转入账户的余额增加，这两个操作要在同一个事务中完成，它们必须使用相同的数据连接对象，
    转入和转出操作的代码分别是两个不同的账户对象的方法。

实验：定义一个全局共享的ThreadLocal变量，然后启动多个线程向该ThreadLocal变量中存储一个随机值，接着各个线程调用另外其他多个类的方法，
     这多个类的方法中读取这个ThreadLocal变量的值，就可以看到多个类在同一个线程中共享同一份数据。

实现对ThreadLocal变量的封装，让外界不要直接操作ThreadLocal变量。
    -对基本类型的数据的封装，这种应用相对很少见。
    -对对象类型的数据的封装，比较常见，即让某个类针对不同线程分别创建一个独立的实例对象。

总结：
    一个ThreadLocal代表一个变量，故其中只能放一个数据，如果有两个变量都要线程范围内共享，则要顶一个两个ThreadLocal变量，
    如果有一百个变量要线程共享呢？那请先定义一个对象来装这一百个变量，然后在ThreadLocal中存储这一个对象。


------------------------------------------------
07_多个线程之间共享数据的方式探讨

-如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有个共享数据，例如，卖票系统就可以这么做。

-如果每个线程执行的代码不同，这时候需要用不同的Runnable对象，有如下两种方式实现这些Runnable对象之间的数据共享：
    -将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。每个线程对共享数据的操作方法也分配到那个对象身上去完成，
         这样容易实现针对该数据进行的各个操作的互斥和通信。
    -将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类的成员变量，每个线程对共享数据的操作方法也分配给外部类，以便实现
         对共享数据的各个操作的互斥和通信，作为内部类的各个Runnable对象调用外部类的这些方法。
    -上面两种方式的组合：将共享数据封装在另外一个对象中，每个线程对共享数据的操作方法也分配那个对象身上去完成，对象作为这个外部类中的成员
         变量或方法中的局部变量，每个线程的Runnable对象作为外部类中的成员内部类或局部内部类。
    -总之，要同步互斥的极端代码最好是分别在几个独立的方法中，这些方法再放在同一个类中，这样比较容易实现它们之间的同步互斥和通信。

-极端且简单的方式，即在任意一个类中定义一个static的变量，这将被所有线程共享。



=====================================
Java5 线程并发库
=====================================

------------------------------------------------
08_java5原子性操作类的应用
Java5 中的线程并发库 java.util.concurrent包及其子包

java.util.concurrent.atomic包
-可以对基本数据，对数组中的基本数据，对类中的基本数据等进行操作
-通过如下两个方法快速理解atomic包的意义：
    -AtomicInteger类的boolean compareAndSet(expectedValue, updateValue)
    -AtomicIntegerArray类的int addAndGet(int i, int delta)
-解释volatile的作用，查看Java语言规范。

了解java.util.concurrent.lock

参考《Java并发编程的艺术》

------------------------------------------------
09_java5线程并发库的应用

线程池
    在线程池的编程模式下，人物是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲的线程，再把任务交给
    内部某个空闲的线程，这就是封装。记住，任务是提交给整个线程池，一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。


-线程池的概念与Executors类的应用
    -创建固定大小的线程池
    -创建缓存线程池
    -创建单一线程池（如何实现线程死掉后重新启动？）
-关闭线程池
    -shutdown与shutdownNow使用

------------------------------------------------



------------------------------------------------



------------------------------------------------


------------------------------------------------


------------------------------------------------


------------------------------------------------


------------------------------------------------


------------------------------------------------


------------------------------------------------


------------------------------------------------


------------------------------------------------


------------------------------------------------


------------------------------------------------









































