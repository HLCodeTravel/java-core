

clrscr函数在conio.h里，
	功能: 清除文本模式窗口 ，也即是清屏
	用法: void clrscr(void);  // clear screen


#ifndef
#define
#endif
	如果在h文件中定义了全局变量，一个c文件包含同一个h文件多次，
	如果不加#ifndef宏定义，会出现变量重复定义的错误；
	如果加了#ifndef，则不会出现这种错误。


char *strstr( char *str, char * substr );
	strstr()函数用来检索子串在字符串中首次出现的位置
	头文件：#include <string.h>
		str为要检索的字符串，substr为要检索的子串。
		返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回NULL。


malloc和strcpy函数结合使用
	response = (char *)malloc(strlen(ptmp)+1);
	if(!response){
	    u_log("malloc failed \n");
	    return NULL;
	}
	strcpy(response,ptmp);


字符串操作技巧
	char post[BUFFER_SIZE] = {'\0'};
    char host_addr[BUFFER_SIZE] = {'\0'};
    char file[BUFFER_SIZE] = {'\0'};


extern
	extern 变量名
		在任何函数体外声明或定义变量时，不加extern可能是定义也可能是声明，编译器选择初始化的那个(最多一个地方对他进行了初始化)，
		如果没有初始化则任选其中一个作为定义，其他为声明，但是加extern肯定是声明; 如果不想让其它源文件链接到，则需要使用static关键字；
		在函数体内声明(注意是声明,在函数体内部不能定义外部变量)使用其他源文件中定义的变量时，
		必须使用extern关键字,因为在函数体内默认为局部变量。

	(2) extern 函数
		函数默认是外部的(在函数体内或函数体外声明一个外部函数,extern关键字均可省略),如果不想让其它源文件链接到，在函数前static关键字，
		虽然在很多情况下extern关键字是可省的,但是为了提高程序的可读性,还是加上它比较好.


	时常在cpp的代码之中看到这样的代码:
			#ifdef __cplusplus
			extern "C" {
			#endif
			//一段代码
			#ifdef __cplusplus
			}
			#endif
	　　
		这样的代码到底是什么意思呢？
		首先，__cplusplus是cpp中的自定义宏，那么定义了这个宏的话表示这是一段cpp的代码，
		也就是说，上面的代码的含义是:如果这是一段cpp的代码，那么加入extern "C"{和}处理其中的代码。

	　　要明白为何使用extern "C"，还得从cpp中对函数的重载处理开始说起。
		在c++中，为了支持重载机制，在编译生成的汇编码中，要对函数的名字进行一些处理，加入比如函数的返回类型等等。
		而在C中，只是简单的函数名字而已，不会加入其他的信息.也就是说:C++和C对产生的函数名字的处理是不一样的


　　试想这样的情况:一个库文件已经用C写好了而且运行得很良好，这个时候我们需要使用这个库文件，但是我们需要使用C++来写这个新的代码。
	如果这个代码使用的是C++的方式链接这个C库文件的话，那么就会出现链接错误.我们来看一段代码:
	首先，我们使用C的处理方式来写一个函数，也就是说假设这个函数当时是用C写成的:
			//f1.c
			extern "C"
			{
			void f1()
			{
			return;
			}
			}


so文件


Makefiles


对于 C 代码，有个像 Valgrind 或者 Purify 这样的工具是必要的。



strcpy
strncpy
memcpy


strncpy()用来复制字符串的前n个字符，其原型为：
    char * strncpy(char *dest, const char *src, size_t n);
    【参数说明】dest 为目标字符串指针，src 为源字符串指针。
    strncpy()会将字符串src前n个字符拷贝到字符串dest。
    不像strcpy()，strncpy()不会向dest追加结束标记'\0'，这就引发了很多不合常理的问题，将在下面的示例中说明。
    注意：src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。
    【返回值】返回字符串dest。



// itoa(kmonitor->workerPid, workerPidStr, 10);
sprintf(workerPidStr, "%d", kmonitor->workerPid);


